#!/usr/bin/env python3
import sys
import numpy as np
import mysql.connector as mysql
import math
import copy

import mysql_connection
from matrices import *
import MinMaxHeapTriplets
from MinMaxHeapTriplets import *
from QuickselectMinTriplets import *

class Comparisons:
    def __init__(self, initial_value=0):
        self.value = initial_value
    def increment(self, amount=1):
        self.value += amount

def retrieve_matrix(matrix_id):
    conn = mysql_connection.new_connection()
    cursor = conn.cursor()

    cursor.execute("SELECT MatrixSeed, MRows FROM Matrices WHERE MatrixID = %s", (matrix_id,))
    result = cursor.fetchone()

    if result:
        seed, rows = result
        matrix = create_matrix_with_ssp(seed, rows)

    cursor.close()
    mysql_connection.close_connection(conn)
    return matrix, rows, matrix_id

def FindHorizontalPivot(matrix, CompsObj):
    aux_matrix = copy.deepcopy(matrix)
    t = 2 * len(matrix) # maximum entry within matrix generated by matrices.py
    deleted_rows = [] # need to keep track of amount of deleted rows to correctly return p at the end
    # np.random.seed = 0
    # Phase 1
    while len(aux_matrix) > math.floor(len(matrix)**(19/20)):
        # np.random.seed += 1 # forcing continued different random seeds
        setof_q_i = []
        for i in range(len(aux_matrix)):
            # np.random.seed += 1
            rand_k = np.random.randint(0, len(aux_matrix[0]))
            setof_q_i.insert(len(setof_q_i), ([aux_matrix[i][rand_k], i, rand_k]))
        # the array in select_kth_triplet is modified, so there needs to be an auxiliary array as the ordered array is still required
        aux_setof_q_i = copy.deepcopy(setof_q_i)
        q_selected = select_kth_triplet(aux_setof_q_i, math.ceil((3/4) * len(setof_q_i)), CompsObj)
        t = min(t, q_selected[0])
        for j in reversed(setof_q_i):
            if j[0] > t:
                aux_matrix = np.delete(aux_matrix, j[1], 0)
                deleted_rows.append(j[1] + len(deleted_rows)) # add row number + already created offset

    # Phase 2
    for rem in range(len(aux_matrix)):
        setof_q_r = []
        # np.random.seed += 1
        rand_k = np.random.randint(0, len(aux_matrix[0]))
        setof_q_r.append([aux_matrix[rem][rand_k], rem, rand_k])
    p = select_kth_triplet(setof_q_r, 1, CompsObj)
    larger_count = 0
    for j in range(len(aux_matrix[p[1]])):
        if p[0] > aux_matrix[p[1], j]:
            larger_count += 1
    if larger_count < math.floor(len(aux_matrix[p[1]])/4):
        return False
    else:
        for row_number in reversed(deleted_rows): # for each deleted row before p[1] increment to keep actual value in matrix
            if row_number < p[1]:
                p[1] += 1
        return p

def FindVerticalPivot(matrix, CompsObj):
    aux_matrix = copy.deepcopy(matrix)
    t = 0 # minimum entry within matrix generated by matrices.py
    deleted_columns = []
    # np.random.seed = 0
    # Phase 1
    while len(aux_matrix[0]) > math.floor(len(matrix[0])**(19/20)):
        # np.random.seed += 1 # forcing continued different random seeds
        setof_q_i = []
        for i in range(len(aux_matrix[0])):
            # np.random.seed += 1
            rand_k = np.random.randint(0, len(aux_matrix))
            setof_q_i.insert(len(setof_q_i), ([aux_matrix[rand_k][i], rand_k, i]))
        # the array in select_kth_triplet is modified, so there needs to be an auxiliary array as the ordered array is still required
        aux_setof_q_i = copy.deepcopy(setof_q_i)
        q_selected = select_kth_triplet(aux_setof_q_i, math.floor((1/4) * len(setof_q_i)), CompsObj)
        t = max(t, q_selected[0])
        for j in reversed(setof_q_i):
            if j[0] < t:
                aux_matrix = np.delete(aux_matrix, j[2], 1)
                deleted_columns.append(j[2] + len(deleted_columns))

    # Phase 2
    for rem in range(len(aux_matrix[0])):
        setof_q_r = []
        # np.random.seed += 1
        rand_k = np.random.randint(0, len(aux_matrix))
        setof_q_r.append([aux_matrix[rand_k][rem], rand_k, rem])
    p = select_kth_triplet(setof_q_r, 1, CompsObj)
    smaller_count = 0
    for j in range(len(aux_matrix[p[2]])):
        if p[0] < aux_matrix[j, p[2]]:
            smaller_count += 1
    if smaller_count < math.floor(len(aux_matrix[p[2]])/4):
        return False
    else:
        for column_number in reversed(deleted_columns):
            if column_number < p[2]:
                p[2] += 1
        return p

def ReduceMatrix(matrix, s, CompsObj):
    while len(matrix) > s:
        print(matrix.shape)
        phor = FindHorizontalPivot(matrix, CompsObj)
        pver = FindVerticalPivot(matrix, CompsObj)
        if phor and pver:
            j = 0
            while j < len(matrix[0]):
                if phor[0] > matrix[phor[1], j] and not pver[2] == j: # exclude the column that contains pver
                    matrix = np.delete(matrix, j, 1)
                    if j < pver[2]:
                        pver[2] = pver[2] - 1
                else:
                    j += 1
            i = 0
            while i < len(matrix):
                if pver[0] < matrix[i, pver[2]]:
                    matrix = np.delete(matrix, i, 0)
                else:
                    i += 1
        else:
            return "failed"
    return matrix


if __name__ == '__main__':
    MID = 18
    CompsObjRandom = Comparisons()
    matrix, rows, matrixid = retrieve_matrix(MID)
    print(ReduceMatrix(matrix, 20, CompsObjRandom))

    