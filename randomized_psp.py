#!/usr/bin/env python3
import sys
import numpy as np
import mysql.connector as mysql
import math
import copy

import mysql_connection
from matrices import *
import MinMaxHeapTriplets
from MinMaxHeapTriplets import *
from QuickselectMinTriplets import *

class Comparisons:
    def __init__(self, initial_value=0):
        self.value = initial_value
    def increment(self, amount=1):
        self.value += amount

def retrieve_matrix(matrix_id):
    conn = mysql_connection.new_connection()
    cursor = conn.cursor()

    cursor.execute("SELECT MatrixSeed, MRows FROM Matrices WHERE MatrixID = %s", (matrix_id,))
    result = cursor.fetchone()

    if result:
        seed, rows = result
        matrix = create_matrix_with_ssp(seed, rows)

    cursor.close()
    mysql_connection.close_connection(conn)
    return matrix, rows, matrix_id

def FindHorizontalPivot(matrix, CompsObj):
    aux_matrix = matrix
    t = 2 * len(matrix) # maximum entry within matrix generated by matrices.py
    # np.random.seed =  
    # for l in range(1):
    # Phase 1
    while len(aux_matrix) > math.floor(len(matrix)**(19/20)):
        # np.random.seed += 1 # forcing continued different random seeds
        setof_q_i = []
        for i in range(len(aux_matrix)):
            # np.random.seed += 1
            rand_k = np.random.randint(0, len(aux_matrix[0]))
            setof_q_i.insert(len(setof_q_i), ([aux_matrix[i][rand_k], i, rand_k]))
        # the array in select_kth_triplet is modified, so there needs to be an auxiliary array as the ordered array is still required
        aux_setof_q_i = copy.deepcopy(setof_q_i)
        q_selected = select_kth_triplet(aux_setof_q_i, math.ceil((3/4) * len(setof_q_i)), CompsObj)
        t = min(t, q_selected[0])
        for j in reversed(setof_q_i):
            if j[0] > t:
                aux_matrix = np.delete(aux_matrix, j[1], 0)

    # Phase 2
    for rem in range(len(aux_matrix)):
        setof_q_r = []
        # np.random.seed += 1
        rand_k = np.random.randint(0, len(aux_matrix[0]))
        setof_q_r.append([aux_matrix[rem][rand_k], rem, rand_k])
    p = select_kth_triplet(setof_q_r, 1, CompsObj)
    larger_count = 0
    for j in range(len(aux_matrix[p[1]])):
        if p[0] > aux_matrix[p[1], j]:
            larger_count += 1
    if larger_count < math.floor(len(aux_matrix[p[1]])/4):
        return False
    else:
        return p
        # j = 0
        # this is not part of the provided algorithm
        # while j < len(aux_matrix[q_selected[1]]):
        #     if aux_matrix[q_selected[1], [j]] < t:
        #         aux_matrix = np.delete(aux_matrix, j, 1)
        #     else:
        #         j += 1
        # return matrix

def FindVerticalPivot(matrix, CompsObj):
    t = 0 # maximum entry within matrix generated by matrices.py
    np.random.seed = 2 * len(matrix)
    for l in range(1):
    # while len(matrix) > 1:
        np.random.seed += 1 # forcing continued different random seeds
        setof_q_i = []
        for i in range(len(matrix[0])):
            np.random.seed += 1
            rand_k = np.random.randint(0, len(matrix))
            setof_q_i.append([matrix[rand_k][i], rand_k, i])
        # Out of bounds error happens with 0, select minimum with 1
        q_selected = select_kth_triplet(setof_q_i, max(math.floor((1/4) * len(setof_q_i)), 1), CompsObj)
        t = max(t, q_selected[0])
        j = 0
        # this is not part of the provided algorithm
        while j < (len(matrix)):
            if matrix[[j], q_selected[2]] > t:
                matrix = np.delete(matrix, j, 0)
            else:
                j += 1
    return matrix

if __name__ == '__main__':
    MID = 20
    CompsObjRandom = Comparisons()
    matrix, rows, matrixid = retrieve_matrix(MID)
    print(FindHorizontalPivot(matrix, CompsObjRandom))

    