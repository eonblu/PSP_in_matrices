#!/usr/bin/env python3
import sys
import numpy as np
import mysql.connector as mysql
import math

import mysql_connection
from matrices import *
import MinMaxHeapTriplets
from MinMaxHeapTriplets import *
from QuickselectMinTriplets import *

class Comparisons:
    def __init__(self, initial_value=0):
        self.value = initial_value
    def increment(self, amount=1):
        self.value += amount

def retrieve_matrix(matrix_id):
    conn = mysql_connection.new_connection()
    cursor = conn.cursor()

    cursor.execute("SELECT MatrixSeed, MRows FROM Matrices WHERE MatrixID = %s", (matrix_id,))
    result = cursor.fetchone()

    if result:
        seed, rows = result
        matrix = create_matrix_with_ssp(seed, rows)

    cursor.close()
    mysql_connection.close_connection(conn)
    return matrix, rows, matrix_id

def FindHorizontalPivot(matrix, CompsObj):
    t = 0 # maximum entry within matrix generated by matrices.py
    np.random.seed = 0
    while len(matrix[0]) > 2:
        np.random.seed += 1 # forcing continued different random seeds
        setof_q_i = []
        for i in range(len(matrix[0])):
            np.random.seed += 1
            rand_k = np.random.randint(0, len(matrix))
            setof_q_i.append([matrix[rand_k][i], i, rand_k])
        # Out of bounds error happens with 0, select minimum with 1
        q_selected = select_kth_triplet(setof_q_i, max(math.floor((1/4) * len(setof_q_i)), 1), CompsObj)
        t = max(t, q_selected[0])
        j = 0
        while j < len(matrix[q_selected[2]-1]):
            if matrix[q_selected[1], [j]] < t:
                matrix = np.delete(matrix, j, 1)
            else:
                j += 1
    return matrix

def FindVerticalPivot(matrix, CompsObj):
    t = 2 * len(matrix) # maximum entry within matrix generated by matrices.py
    while len(matrix) > 2:
        np.random.seed += 1 # forcing continued different random seeds
        setof_q_i = []
        for i in range(len(matrix)):
            np.random.seed += 1
            rand_k = np.random.randint(0, len(matrix[0]))
            setof_q_i.append([matrix[i][rand_k], i, rand_k])
        q_selected = select_kth_triplet(setof_q_i, math.ceil((3/4) * len(setof_q_i)), CompsObj)
        t = min(t, q_selected[0])
        j = 0
        while j < len(matrix):
            if matrix[[j], q_selected[2]] > t:
                matrix = np.delete(matrix, j, 0)
            else:
                j += 1
    return matrix

if __name__ == '__main__':
    MID = 3
    CompsObjRandom = Comparisons()
    matrix, rows, matrixid = retrieve_matrix(MID)
    print(matrix.shape)
    matrix = FindHorizontalPivot(matrix, CompsObjRandom)
    print(matrix.shape)
    matrix = FindVerticalPivot(matrix, CompsObjRandom)
    print(matrix)

    