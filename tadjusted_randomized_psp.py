#!/usr/bin/env python3
import sys
import numpy as np
import mysql.connector as mysql
import math
import copy
import random

import mysql_connection
from matrices import *
from QuickselectMinTriplets import *
from deterministic_psp import *

class Comparisons:
    def __init__(self, initial_value=0):
        self.value = initial_value
    def increment(self, amount=1):
        self.value += amount

def TAdjustedFindHorizontalPivot(matrix, CompsObj):
    t = 1000000000 # maximum entry within matrix generated by matrices.py
    ignored_rows = set() # need to keep track of deleted rows to correctly return p at the end
    columns_to_remove = []
    # calculate matrix size for loop clause
    if len(matrix) > 400:
        phase1_endsize = math.floor(len(matrix)**(1/2))
        s = 7
    else:
        phase1_endsize = math.floor(len(matrix)**(19/20))
        s = 5
    # Phase 1
    while len(matrix) - len(ignored_rows) > phase1_endsize:
        setof_q_i = []
        for i in range(len(matrix)):
            if not i in ignored_rows: # if row was removed in earlier run of this loop
                rand_k = random.randint(0, len(matrix[0])-1)
                setof_q_i.insert(len(setof_q_i), ([matrix[i][rand_k], i, rand_k])) # this is an append
        # the array in select_kth_triplet is modified, so there needs to be an auxiliary array as the ordered array is still required
        aux_setof_q_i = copy.deepcopy(setof_q_i)
        q_selected = select_kth_triplet(aux_setof_q_i, math.ceil((3/4) * len(setof_q_i)), CompsObj)
        t = min(t, q_selected[0])
        for j in reversed(setof_q_i):
            CompsObj.increment()
            if j[0] > t and len(ignored_rows) < len(matrix) - 1: # make sure that not all rows are ignored -> set_q_r is not empty
                ignored_rows.add(j[1]) # add row number to ignore in phase 2
       
    # Phase 2
    setof_q_r = []
    for rem in range(len(matrix)):
        if not rem in ignored_rows: # if row was removed in earlier step, ignore
            sample_pick = random.sample(range(len(matrix[0])), s)
            R = []
            for sample in sample_pick:
                R.append([matrix[rem, sample], rem, sample])
            largest_sample = R[0]
            for r in R:
                CompsObj.increment()
                if r[0] > largest_sample[0]:
                    largest_sample = r
            setof_q_r.append(largest_sample)

    p = setof_q_r[0]
    for q_r in setof_q_r: # select minimum
        CompsObj.increment()
        if q_r[0] < p[0]:
            p = q_r
    for j in range(len(matrix[0])):
        CompsObj.increment() # Comparison to check for p > k/4 entries - this could be removed if we trust that we remove "enough" columns
        if p[0] > matrix[p[1], j]:
            columns_to_remove.append(j)
    if p[0] > t:
        return False, [-1]
    elif len(columns_to_remove) < math.floor(len(matrix[0])/4): # soft failure
        return p, columns_to_remove
    else:
        return p, columns_to_remove

# equivalent with min/max reversed to HorizontalPivot
def TAdjustedFindVerticalPivot(matrix, CompsObj):
    t = 0
    ignored_columns = set()
    rows_to_remove = []
    # calculate matrix size for loop clause, lower sample size for smaller matrices
    if len(matrix) > 400:
        phase1_endsize = math.floor(len(matrix)**(1/2))
        s = 7
    else:
        phase1_endsize = math.floor(len(matrix)**(19/20))
        s = 5
    # Phase 1
    while len(matrix[0]) - len(ignored_columns) > phase1_endsize:
        setof_q_i = []
        for i in range(len(matrix[0])):
            if not i in ignored_columns:
                rand_k = random.randint(0, len(matrix)-1)
                setof_q_i.insert(len(setof_q_i), ([matrix[rand_k][i], rand_k, i]))
        aux_setof_q_i = copy.deepcopy(setof_q_i)
        q_selected = select_kth_triplet(aux_setof_q_i, max(math.floor((1/4) * len(setof_q_i)), 1), CompsObj)
        t = max(t, q_selected[0])
        for j in reversed(setof_q_i):
            CompsObj.increment()
            if j[0] < t and len(ignored_columns) < len(matrix[0]) - 1:
                ignored_columns.add(j[2])

    # Phase 2
    setof_q_r = []
    for rem in range(len(matrix[0])):
        if not rem in ignored_columns:
            sample_pick = random.sample(range(len(matrix)), s)
            R = []
            for sample in sample_pick:
                R.append([matrix[sample, rem], sample, rem])
            smallest_sample = R[0]
            for r in R:
                CompsObj.increment()
                if r[0] < smallest_sample[0]:
                    smallest_sample = r
            setof_q_r.append(smallest_sample)

    p = setof_q_r[0]
    for q_r in setof_q_r:
        CompsObj.increment()
        if q_r[0] > p[0]:
            p = q_r
    for j in range(len(matrix)):
        CompsObj.increment()
        if p[0] < matrix[j, p[2]]:
            rows_to_remove.append(j)
    if p[0] < t:
        return False, [-1]
    elif len(rows_to_remove) < math.floor(len(matrix)/4):
        return p, rows_to_remove
    else:
        return p, rows_to_remove

def TAdjustedReduceMatrix(matrix, CompsObj):
    while len(matrix) > 10 or len(matrix[0]) > 10:
        if len(matrix[0]) > 10: # Prevent unecessary comparisons if one dimension is already minimal size
            p_hor, columns_to_remove = TAdjustedFindHorizontalPivot(matrix, CompsObj)
        if len(matrix) > 10:
            p_ver, rows_to_remove = TAdjustedFindVerticalPivot(matrix, CompsObj)
        if p_hor and p_ver:
            if len(matrix[0]) - len(columns_to_remove) > 10: # Prevent Non square final matrix
                matrix = np.delete(matrix, columns_to_remove, 1)
            else:
                for col in reversed(columns_to_remove):
                    if len(matrix[0]) > 10: 
                        matrix = np.delete(matrix, col, 1)
            if len(matrix) - len(rows_to_remove) > 10:
                    matrix = np.delete(matrix, rows_to_remove, 0)
            else:
                for row in reversed(rows_to_remove):
                    if len(matrix) > 10:
                        matrix = np.delete(matrix, row, 0)
    return BienstockBase(matrix, 10, CompsObj)[0]

def TAdjustedReduceMatrixTestsuite(matrix, CompsObj):
    p_hor, columns_to_remove = TAdjustedFindHorizontalPivot(matrix, CompsObj)
    p_ver, rows_to_remove = TAdjustedFindVerticalPivot(matrix, CompsObj)
    return [columns_to_remove, rows_to_remove]
